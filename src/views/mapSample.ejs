<!DOCTYPE html>
<html>
  <head>
    <title>클러스터링 시각화 테스트</title>
    <meta charset="utf-8" />
    <!-- 오픈API -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script>
      let canvas, ctx;
      let gData, gSpots, gCentroids, gRadius, gNonDupCentroids, gValidCentroids;
      let gMaxX, gMinX, gMaxY, gMinY;
      let spotPointSize = 2;
      let centPointSize = spotPointSize * 2;
      let radiusCircleSize = 0;
      const blankMultiplier = 20; // 높을수록 캔버스 여백 비율이 작아진다.
      let blankSizeX, blankSizeY;
      const canvasWidth = 4800.0;
      const canvasHeight = 4800.0;
      const clipMinLat = 33.109684; // 제주 지역만 필터링
      const clipMaxLat = 33.650946;
      const clipMinLng = 126.032175;
      const clipMaxLng = 127.048411;

      const palette = [
        'brown',
        'yellow',
        'purple',
        'darkgreen',
        'aqua',
        'gray',
      ];

      $.ajax({
        type: 'post',
        url: 'http://localhost:3000/schedule/makeSchedule',
        async: true,
        headers: {
          'Content-Type': 'application/json',
          Authorization:
            'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJncmFkZSI6Im5vbk1lbWJlciIsInRva2VuSWQiOiIxIiwiaWF0IjoxNjY0NTIwMzU4fQ.t_Bqt3yqDlInUZ29g6tFc3FVGcQ3pE6A47eqerPoJpw',
        },
        // data: JSON.stringify({
        //   ingNow: 'ing',
        //   companion: 'alone',
        //   period: '30',
        //   travelType: ['rest', 'healing', 'exploration'],
        //   destination: 'recommend',
        //   travelHard: '5',
        // }),
        data: JSON.stringify({
          ingNow: 'ing',
          companion: 'alone',
          period: '15',
          travelType: ['rest', 'meeting', 'activity'],
          destination: 'recommend',
          travelHard: '8',
        }),
        success: async function (result) {
          // console.log(result);
          const data = result.IBparams.clusterRes;
          gValidCentroids = [...result.IBparams.validCentroids];
          console.log(gValidCentroids);
          const {
            spotsGeoLocation,
            centroids,
            centHistoryByStage,
            r,
            nonDupCentroids,
          } = data;

          // gSpots = spotsGeoLocation;
          // console.log(gSpots);
          // gCentroids = centroids;
          // gHistories = centHistoryByStage;
          // gNonDupCentroids = nonDupCentroids;

          gData = data;
          gSpots = spotsGeoLocation.filter(
            v =>
              v.lat >= clipMinLat &&
              v.lat < clipMaxLat &&
              v.lng >= clipMinLng &&
              v.lng < clipMaxLng,
          );
          console.log(gSpots);
          gCentroids = centroids;
          gHistories = centHistoryByStage;
          gNonDupCentroids = nonDupCentroids;
          // gCentroids = centroids.filter(
          //   v =>
          //     v.lat >= clipMinLat &&
          //     v.lat < clipMaxLat &&
          //     v.lng >= clipMinLng &&
          //     v.lng < clipMaxLng,
          // );
          // gHistories = centHistoryByStage.filter(
          //   v =>
          //     v.lat >= clipMinLat &&
          //     v.lat < clipMaxLat &&
          //     v.lng >= clipMinLng &&
          //     v.lng < clipMaxLng,
          // );
          // gNonDupCentroids = nonDupCentroids.filter(
          //   v =>
          //     v.lat >= clipMinLat &&
          //     v.lat < clipMaxLat &&
          //     v.lng >= clipMinLng &&
          //     v.lng < clipMaxLng,
          // );
          gRadius = r;

          const { maxX, minX, maxY, minY } = await gSpots.reduce(
            (result, spot) => {
              const x = spot.lng;
              const y = spot.lat;
              const newRes = { ...result };
              if (x >= newRes.maxX) newRes.maxX = x;
              if (x < newRes.minX) newRes.minX = x;
              if (y >= newRes.maxY) newRes.maxY = y;
              if (y < newRes.minY) newRes.minY = y;
              return newRes;
            },
            {
              maxX: -9999,
              minX: 9999,
              maxY: -9999,
              minY: 9999,
            },
          );
          console.log(
            `maxX:${maxX}, maxY:${maxY} \nminX:${minX}, minY:${minY}`,
          );

          blankSizeX = (maxX - minX) / blankMultiplier;
          blankSizeY = (maxY - minY) / blankMultiplier;

          gMaxX = maxX + blankSizeX;
          gMinX = minX - blankSizeX;
          gMaxY = maxY + blankSizeY;
          gMinY = minY - blankSizeY;
        },
        error: function (request, status, error) {
          console.log(error);
        },
      });
    </script>

    <script>
      function degreeToMeter(lon1, lat1, lon2, lat2) {
        // generally used geo measurement function
        const R = 6378.137; // Radius of earth in KM
        const dLat = (lat2 * Math.PI) / 180 - (lat1 * Math.PI) / 180;
        const dLon = (lon2 * Math.PI) / 180 - (lon1 * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const d = R * c;
        return d * 1000; // meters
      }

      async function estGeoLocFromMeter(targetMeter) {
        let estMeter = degreeToMeter(gMinX, gMinY, gMaxX, gMinY);
        let rightX = gMaxX - gMinX;
        let estX = rightX;
        let deltaMeter;
        let delta;

        let down = 0;
        let up = 0;
        let cnt = 0;
        const pro = new Promise(resolve => {
          while (Math.abs(targetMeter - estMeter) > 0.1 && cnt < 1000) {
            cnt++;
            // console.log(
            //   `[${cnt}] target:${targetMeter}, estMeter:${estMeter}, deltaMeter: ${deltaMeter}, delta: ${delta},  estX: ${estX} `,
            // );
            delta = rightX / 2;
            deltaMeter = degreeToMeter(0, gMinY, delta, gMinY);
            if (estMeter > targetMeter) {
              estX -= delta;
              down++;
              // console.log(`[${cnt}][down(${down})]`);
            } else {
              estX += delta;
              up++;
              // console.log(`[${cnt}  up(${up})] `);
            }
            estMeter = degreeToMeter(0, gMinY, estX, gMinY);
            rightX /= 2;
          }
          // console.log(`down ${down}, up:${up}`);
          resolve(true);
        });

        await pro;

        return {
          lng: estX + gMinX,
          lat: gMinY,
        };
      }

      function geoLocToCoord(geo) {
        const { lng, lat } = geo;
        let distributionThickness = 0;
        if (gMaxX - gMinX - (gMaxY - gMinY) > 0) {
          distributionThickness = gMaxX - gMinX;
        } else {
          distributionThickness = gMaxY - gMinY;
        }

        const transToCanvasX =
          ((lng - gMinX) * canvasWidth) / distributionThickness;
        const transToCanvasY =
          canvasHeight - ((lat - gMinY) * canvasHeight) / distributionThickness;
        return { x: transToCanvasX, y: transToCanvasY };
      }

      const drawItems = (type, option) => {
        const stageNo = option?.stageNo;
        const historyLength = option?.historyLength;
        const onlyNonDup = option?.onlyNonDup ?? false;

        return (item, i) => {
          const { size, color } = (() => {
            switch (type) {
              case 'spot':
              default:
                return { size: spotPointSize, color: 'gray' };
              case 'centroid':
                return { size: centPointSize, color: 'red' };
              case 'history':
                return {
                  size: Math.round(spotPointSize * 1.5),
                  color: palette[i],
                };
              case 'stageNo':
                return {
                  size: Math.round(spotPointSize * 1.5),
                  color: palette[i % palette.length],
                };
            }
          })();
          const p = new Promise(resolve => {
            const { x, y } = geoLocToCoord(item);
            /// 반경 표시 써클
            if (
              (type === 'history' || type === 'stageNo') &&
              (gNonDupCentroids.find(v => v.idx === i) || onlyNonDup === false)
            ) {
              historyCtx.beginPath();

              historyCtx.arc(x, y, size, 0, 2 * Math.PI);
              historyCtx.stroke();
              historyCtx.fillStyle = color;
              historyCtx.fill();
              historyCtx.font = '30px Comic Sans MS';
              historyCtx.fillText(
                type === 'stageNo' ? `${i}` : `${stageNo}`,
                x,
                y,
                // x + 5 - Math.floor(5 * Math.random()),
                // y + 5 - Math.floor(5 * Math.random()),
              );
              historyCtx.closePath();

              historyCtx.beginPath();

              historyCtx.arc(x, y, radiusCircleSize, 0, 2 * Math.PI);

              historyCtx.globalAlpha = 0.6;
              historyCtx.strokeStyle = color;

              /// 마지막 스테이지일 경우에는 반경에 색깔 채우기 효과
              if (stageNo < historyLength - 1) {
                historyCtx.stroke();
              } else {
                historyCtx.stroke();
                historyCtx.globalAlpha = 0.03;
                historyCtx.fill();
              }

              historyCtx.closePath();
              historyCtx.globalAlpha = 1;
            } else {
              ctx.beginPath();

              // if (
              //   // item &&
              //   // item.name &&
              //   item.name.includes('화순곶자왈') ||
              //   item.name.includes('궷물오름') ||
              //   item.name.includes('해방촌') ||
              //   item.name.includes('와이키키') ||
              //   item.name.includes('독도전망대케이블카') ||
              //   item.name.includes('요세미티') ||
              //   item.name.includes('먼디') ||
              //   item.name.includes('프리스코 페닌슐라 휴양지') ||
              //   item.name.includes('Marinalia.es') ||
              //   item.name.includes('Cape Maeda') ||
              //   item.name.includes(
              //     'Al Masyhur International Travel & Tours Sdn Bhd (AMI Travel)',
              //   ) ||
              //   item.name.includes('Pulau Payar Marine Park')
              // ) {
              //   console.log(item);
              //   ctx.font = '60px Comic Sans MS';
              //   ctx.fillText(
              //     `${item.name}`,
              //     x + 5 - Math.floor(5 * Math.random()),
              //     y + 5 - Math.floor(5 * Math.random()),
              //   );
              // }

              ctx.arc(x, y, size, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.strokeStyle = 'black';
              ctx.fillStyle = color;
              ctx.fill();
              ctx.closePath();
            }
            // console.log(`[${i}]: x:${x}, y:${y}`);
            resolve(true);
          });
          return p;
        };
      };

      async function load() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        historyCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        console.log(`radius:${gRadius}`);
        const geo = await estGeoLocFromMeter(gRadius);
        const { x: rulerX, y: rulerY } = geoLocToCoord(geo);
        console.log(`geo:${JSON.stringify(geo)}`);
        console.log(`rulerX:${rulerX}, rulerY:${rulerY}`);
        console.log(`estMeter: ${degreeToMeter(gMinX, gMinY, geo.lng, gMinY)}`);

        /// mean-Shift 알고리즘 연산반경(radius) 축척 표시
        ctx.beginPath();
        ctx.moveTo(0, canvasHeight);
        ctx.lineTo(rulerX, rulerY);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 2;
        ctx.font = '30px Comic Sans MS';
        ctx.fillText(`radius: ${gRadius}m`, 50, canvasHeight - 15);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(50, canvasHeight - 50);
        ctx.lineTo(rulerX + 50, rulerY - 50);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 2;
        ctx.font = '30px Comic Sans MS';
        ctx.fillText(`radius: ${gRadius}m`, 50, canvasHeight - 15);
        ctx.stroke();

        const spotsPromises = gSpots.map(drawItems('spot'));
        const centroidPromises = gCentroids.map(drawItems('centroid'));
        await Promise.all([...spotsPromises, ...centroidPromises]);
      }

      /// ex) 전체 클러스터 형성과정 표시 => play() <---  전체 centroids 들의 stage 별 변화 play(default 옵션)
      /// ex) 미중복 클러스터의 형성과정 표시 => play({onlyNonDup: true}) <--- 중복되지 않는 centroids 결과값만 보여줌
      /// ex) 특정 클러스터의 형성과정 표시 => play({centId: 2})
      /// ex) 특정 스테이지의 클러스터 상태만 표시 => play({stageNo: 22});
      async function play(options) {
        const { onlyNonDup, stageNo, centId } = (() => {
          if (!options) {
            return {
              onlyNonDup: undefined,
              stageNo: undefined,
              centId: undefined,
            };
          }
          const { onlyNonDup, stageNo, centId } = options;
          return {
            onlyNonDup,
            stageNo,
            centId,
          };
        })();

        historyCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        const geo = await estGeoLocFromMeter(gRadius);
        const { x } = geoLocToCoord(geo);
        radiusCircleSize = x;

        /// 특정 스테이지의 클러스터 상태만 표시
        if (typeof stageNo === 'number') {
          const { centroids } = gHistories[stageNo];
          const promises = centroids.map(
            drawItems('stageNo', {
              stageNo,
              historyLength: stageNo,
              onlyNonDup: false,
            }),
          );
          await Promise.all(promises);
          return;
        }

        for await (const stage of gHistories) {
          const pro = new Promise(resolve => {
            setTimeout(async () => {
              const { stageNo } = stage;
              let centroids = stage.centroids;

              /// centId가 있다면 centId에 해당하는 클러스터만 표시하도록 표본을 조정
              if (typeof centId === 'number') {
                console.log(`stageNo:${stageNo}`, centroids[centId]);
                centroids = [centroids[centId]];
              } else {
                console.log(stage);
              }

              const promises = centroids.map(
                drawItems('history', {
                  stageNo,
                  historyLength: gHistories.length,
                  onlyNonDup,
                }),
              );
              await Promise.all(promises);
              resolve(true);
            }, 1000);
          });
          await pro;
        }
      }

      /// 클러스터 형성과정중 n번 이상 포함하는 요소의 수가 변한 클러스터 배열을 리턴하는 테스트 함수
      function manyChangedCentroids(n) {
        return gCentroids.filter(v => {
          const arr = v.histories.split('-');
          let prevNumber = 'start';
          const diffNum = arr.filter(c => {
            if (prevNumber === 'start' || prevNumber === c) {
              prevNumber = c;
              return false;
            }
            prevNumber = c;
            return true;
          });
          return diffNum.length >= n;
        });
      }

      function decreasedCaseCentoirds() {
        return gCentroids.filter(v => {
          const arr = v.histories.split('-');
          let prevNumber = 'start';
          const diffNum = arr.filter(c => {
            if (prevNumber === 'start' || Number(prevNumber) <= Number(c)) {
              prevNumber = c;
              return false;
            }
            prevNumber = c;
            return true;
          });
          return diffNum.length >= 1;
        });
      }

      function drawPoint({ lng, lat }) {
        const { x, y } = geoLocToCoord({ lat, lng });
        console.log(x, y);
        ctx.beginPath();

        ctx.arc(x, y, centPointSize, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'yellow';
        ctx.fill();
        ctx.closePath();
      }
    </script>
  </head>
  <body style="margin: 0">
    <canvas id="spotCanvas" width="4800" height="4800" margin> </canvas>
    <canvas
      id="historyCanvas"
      width="4800"
      height="4800"
      style="position: absolute; top: 0; left: 0"
    >
    </canvas>
    <script>
      spotCanvas = document.getElementById('spotCanvas');
      historyCanvas = document.getElementById('historyCanvas');
      ctx = spotCanvas.getContext('2d');
      historyCtx = historyCanvas.getContext('2d');
      console.log(canvas);
    </script>
  </body>
</html>
